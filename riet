#!/usr/bin/env python3

import itertools as it, operator as op, functools as ft
import os, sys, logging, re, time, math, subprocess
import datetime as dt, collections as cs
import contextlib, tempfile, stat

import docutils, pytz


class LogMessage(object):
	def __init__(self, fmt, a, k): self.fmt, self.a, self.k = fmt, a, k
	def __str__(self): return self.fmt.format(*self.a, **self.k) if self.a or self.k else self.fmt

class LogStyleAdapter(logging.LoggerAdapter):
	def __init__(self, logger, extra=None):
		super(LogStyleAdapter, self).__init__(logger, extra or {})
	def log(self, level, msg, *args, **kws):
		if not self.isEnabledFor(level): return
		log_kws = {} if 'exc_info' not in kws else dict(exc_info=kws.pop('exc_info'))
		msg, kws = self.process(msg, kws)
		self.logger._log(level, LogMessage(msg, args, kws), (), **log_kws)

get_logger = lambda name: LogStyleAdapter(logging.getLogger(name))
log = get_logger('main')

class adict(dict):
	def __init__(self, *args, **kwargs):
		super().__init__(*args, **kwargs)
		self.__dict__ = self

@contextlib.contextmanager
def safe_replacement(path, *open_args, mode=None, **open_kws):
	path = str(path)
	if mode is None:
		try: mode = stat.S_IMODE(os.lstat(path).st_mode)
		except OSError: pass
	open_kws.update( delete=False,
		dir=os.path.dirname(path), prefix=os.path.basename(path)+'.' )
	if not open_args: open_kws['mode'] = 'w'
	with tempfile.NamedTemporaryFile(*open_args, **open_kws) as tmp:
		try:
			if mode is not None: os.fchmod(tmp.fileno(), mode)
			yield tmp
			if not tmp.closed: tmp.flush()
			os.rename(tmp.name, path)
		finally:
			try: os.unlink(tmp.name)
			except OSError: pass



### Date/time processing helpers

class TSParseError(Exception): pass
class TSOverflow(Exception): pass

IntervalFilter = cs.namedtuple('interval_filter', 'mo_days weekdays time tz')
IntervalDelta = cs.namedtuple('interval_delta', 'y mo w d h m s')

weekday_names = 'mon tue wed thu fri sat sun'.title().split()
delta_1s, delta_1d = dt.timedelta(seconds=1), dt.timedelta(days=1)

_short_ts_days = dict(
	y=365.25, yr=365.25, year=365.25,
	mo=30.5, month=30.5, w=7, week=7, d=1, day=1 )
_short_ts_s = dict(
	h=3600, hr=3600, hour=3600,
	m=60, min=60, minute=60,
	s=1, sec=1, second=1 )
def _short_ts_re():
	sub_sort = lambda d: sorted(
		d.items(), key=lambda kv: (kv[1], len(kv[0])), reverse=True )
	ts_re = ['^'] + [
		r'(?P<{0}>\d*{0}\b\s*)?'.format(k)
		for k, v in it.chain.from_iterable(
			map(sub_sort, [_short_ts_days, _short_ts_s]) ) ] + ['$']
	return re.compile(''.join(ts_re), re.I | re.U)
_short_ts_re = _short_ts_re()

_filter_weekdays = list(map(str.split,
	[ 'mon monday', 'tu tue tuesday tues', 'wed wednesday',
		'th thu thursday thur thurs', 'fri friday', 'sat saturday', 'sun sunday' ] ))
_filter_weekdays_re = '(?:{})'.format(
	'|'.join('|'.join(wd) for wd in _filter_weekdays) )

def _delta_keys():
	ks = dict()
	for delta_k in IntervalDelta._fields:
		for vs in _short_ts_days, _short_ts_s:
			if delta_k not in vs: continue
			v_chk = vs[delta_k]
			for k, v in vs.items():
				if v == v_chk: ks[k] = delta_k
			break
		else: raise TSParseError(delta_k)
	return ks
_delta_keys = _delta_keys()
_delta_keys_dt = dict(
	y=(1, 'year'), mo=(1, 'month'), w=dt.timedelta(weeks=1), d=dt.timedelta(days=1),
	h=dt.timedelta(hours=1), m=dt.timedelta(minutes=1), s=dt.timedelta(seconds=1) )

_parse_int = lambda v: int(''.join(c for c in v if c.isdigit()) or 1)

def get_local_tz():
	# Cached on first access to avoid dbus call on import
	if get_local_tz.cache: return get_local_tz.cache

	tz = os.environ.get('TZ', '').strip()
	if tz:
		get_local_tz.cache = pytz.timezone(tz)
		return get_local_tz.cache

	import ctypes as ct

	class sd_bus(ct.Structure): pass
	class sd_bus_error(ct.Structure):
		_fields_ = [('name', ct.c_char_p), ('message', ct.c_char_p), ('need_free', ct.c_int)]
	class sd_bus_msg(ct.Structure): pass

	lib = ct.CDLL('libsystemd.so')

	def run(call, *args, sig=None, check=True):
		func = getattr(lib, call)
		if sig: func.argtypes = sig
		res = func(*args)
		if check and res < 0: raise OSError(-res, os.strerror(-res))
		return res

	bus, error, reply = (
		ct.POINTER(sd_bus)(), sd_bus_error(), ct.POINTER(sd_bus_msg)() )
	run( 'sd_bus_open_system', ct.byref(bus),
		sig=[ct.POINTER(ct.POINTER(sd_bus))] )
	try:
		run( 'sd_bus_get_property',
			bus,
			b'org.freedesktop.timedate1',
			b'/org/freedesktop/timedate1',
			b'org.freedesktop.timedate1',
			b'Timezone',
			ct.byref(error),
			ct.byref(reply),
			b's',
			sig=[
				ct.POINTER(sd_bus),
				ct.c_char_p, ct.c_char_p, ct.c_char_p, ct.c_char_p,
				ct.POINTER(sd_bus_error),
				ct.POINTER(ct.POINTER(sd_bus_msg)),
				ct.c_char_p ] )
		tz = ct.c_char_p()
		n = run( 'sd_bus_message_read', reply, b's', ct.byref(tz),
			sig=[ct.POINTER(sd_bus_msg), ct.c_char_p, ct.POINTER(ct.c_char_p)] )
		assert n > 0, n
	finally:
		run('sd_bus_flush', bus, check=False)
		run('sd_bus_close', bus, check=False)
		run('sd_bus_unref', bus, check=False)
	get_local_tz.cache = pytz.timezone(tz.value.decode())
	return get_local_tz.cache
get_local_tz.cache = None

def conv_ts_utc(ts):
	'Interpret any naive datetime as local-tz and convert to UTC.'
	if not ts: return
	if not ts.tzinfo: ts = get_local_tz().localize(ts, is_dst=None)
	return ts.astimezone(pytz.utc)

def conv_ts_local(ts):
	'Convert datetime to local timezone for human output.'
	if not ts: return
	return ts.astimezone(get_local_tz())

def parse_delta_spec(ts_str):
	m = _short_ts_re.search(ts_str)
	if not m or not any(m.groups()): raise TSParseError(ts_str)
	delta = dict.fromkeys(IntervalDelta._fields, 0)
	for k, delta_k in _delta_keys.items():
		try: n = _parse_int(m.group(k)) if m.group(k) else 0
		except IndexError: n = 0
		delta[delta_k] += n
	for delta_k, n in delta.items():
		v = _delta_keys_dt[delta_k]
		if isinstance(v, dt.timedelta): v *= n
		else: v = v[0]*n, v[1]
		delta[delta_k] = v
	return IntervalDelta(**delta)

def parse_duration(ts_str):
	m = _short_ts_re.search(ts_str)
	if not m or not any(m.groups()): raise TSParseError(ts_str)
	delta = list()
	for units in _short_ts_days, _short_ts_s:
		val = 0
		for k, v in units.items():
			try:
				if not m.group(k): continue
				n = _parse_int(m.group(k))
			except IndexError: continue
			val += n * v
		delta.append(val)
	return dt.timedelta(*delta)

def parse_ts(ts_str, in_future=True):
	assert isinstance(ts_str, str), [type(ts_str), repr(ts_str)]
	ts = None
	if not ts:
		match = re.search( # common BE format
			r'^(?P<date>(?:\d{2}|(?P<Y>\d{4}))-\d{2}-\d{2})'
			r'(?:[ T](?P<time>\d{2}(?::\d{2}(?::\d{2})?)?)?)?$', ts_str )
		if match:
			tpl = 'y' if not match.group('Y') else 'Y'
			tpl, ts_str = '%{}-%m-%d'.format(tpl), match.group('date')
			if match.group('time'):
				tpl_time = ['%H', '%M', '%S']
				ts_str_time = match.group('time').split(':')
				ts_str += ' ' + ':'.join(ts_str_time)
				tpl += ' ' + ':'.join(tpl_time[:len(ts_str_time)])
			try: ts = dt.datetime.strptime(ts_str, tpl)
			except ValueError: pass
	if not ts:
		# coreutils' "date" parses virtually everything, but is more expensive to use
		ts_ext = [ts_str]
		while True:
			res = subprocess.run( ['date', '+%s', '-d', ' '.join(ts_ext)],
					stdout=subprocess.PIPE, stderr=subprocess.DEVNULL )
			if not res.returncode:
				val = int(res.stdout.strip())
				# Try to add +1 day to simple timestamps like 3:00 if they're in the past
				# Whitelisted cases: 1:00, 4am, 5am GMT, 3:30 UTC-4
				if in_future and 0 < time.time() - val <= 24*3600 and re.search(
						r'(?i)^[\d:]+\s*(am|pm)?\s*([-+][\d:]+|\w+|\w+[-+][\d:]+)?$', ts_str.strip() ):
					ts_ext.append('+ 1 day') # note: just val+=24*3600 can be incorrect due to DST
					continue
				ts = dt.datetime.fromtimestamp(val) # note: naive dt in local tz
				if ( in_future and 0 < time.time() - val <= 365*24*3600
					and not re.search(r'\b\d{4}\b', ts_str) ): ts = ts.replace(year=ts.year+1)
			break
	if ts: return ts
	raise TSParseError(ts_str)

def parse_ts_interval(ts_str):
	# EVERY:
	#   "every" {
	#     [ ( NN[suffix][ "-" MM[suffix]] )+ | DELTA-DATE-SPEC ]
	#       [WD[-WD]]+
	#       ["at"] [TIME ["[" TZ "]"]]
	#     | DELTA-SPEC "interval" }
	#   suffix: st, nd, rd, th
	#   example: every 1st-11th at 5am UTC
	# DELTA-SPEC:
	#   ( N || unit )+
	#   units:
	#     y, yr, year, mo, month, w, week, d, day,
	#     h, hr, hour, m, min, minute, s, sec, second
	#   example: 3mo 1d 5hrs 10minutes 30s
	# DELTA-DATE-SPEC:
	#   subset of DELTA-SPEC wrt allowed units
	#   units: y, yr, year, mo, month, w, week, d, day
	# WD: see _filter_weekdays abbrevs
	# TIME: [H]H[:MM[:SS]] ["am"|"pm"]
	# TZ: ( "UTC" | ("+"|"-") HH:MM | region/place )

	# DELTA-SPEC "interval"
	m = re.search(r'(?i)^(.*)\binterval$', ts_str)
	if m: return parse_delta_spec(m.group(1).strip())

	# More conventional specification
	ts_str_base, dt_filter = ts_str, dict.fromkeys(IntervalFilter._fields)
	mo_days = dt_filter['mo_days'] = set()
	weekdays = dt_filter['weekdays'] = set()
	ts_str_re = r'(\s+(?P<rest>.*)|$)'

	# ( NN[suffix][ "-" MM[suffix]] )+
	while True:
		m = re.search( r'(?i)^(?P<a>\d+)(st|nd|rd|th)?'
			r'(\s*-\s*(?P<b>\d+)(st|nd|rd|th)?)?' + ts_str_re, ts_str )
		if not m: break
		a, b, ts_str = m.group('a'), m.group('b'), m.group('rest') or ''
		if b: mo_days.update(range(int(a), int(b)+1))
		else: mo_days.add(int(a))
	# DELTA-DATE-SPEC
	spec, delta, ts_str = ts_str.split(), None, list()
	while True:
		if not spec: break
		try: delta = parse_delta_spec(' '.join(spec))
		except TSParseError: pass
		else: break
		ts_str.append(spec.pop())
	if delta:
		if mo_days: raise TSParseError(' '.join(spec), mo_days, delta)
		if delta.h or delta.m or delta.s: raise TSParseError(' '.join(spec), delta)
		dt_filter['mo_days'] = delta
	ts_str = ' '.join(reversed(ts_str))
	# [WD[-WD]]+
	wd_re = re.compile( r'(?i)^(?P<a>{0})(\s*-\s*'
		r'(?P<b>{0}))?{1}'.format(_filter_weekdays_re, ts_str_re) )
	wd_match = lambda s: next( n for n, wd in
		enumerate(_filter_weekdays, 1) if s.startswith(wd[0]) )
	while True:
		m = wd_re.search(ts_str)
		if not m: break
		a, b, ts_str = m.group('a'), m.group('b'), m.group('rest') or ''
		if b: weekdays.update(range(wd_match(a.lower()), wd_match(b.lower())+1))
		else: weekdays.add(wd_match(a.lower()))
	# "at"
	m = re.search(r'(?i)^\s*at' + ts_str_re, ts_str)
	if m: ts_str = m.group('rest') or ''
	# TIME
	m = re.search( r'(?i)^(?P<h>\d{1,2})(:(?P<m>\d{2})'
		r'(:(?P<s>\d{2}))?)?(\s*(?P<x>am|pm))?' + ts_str_re, ts_str )
	if m:
		x, ts_str = m.group('x'), m.group('rest') or ''
		h, m, s = (int(m.group(k) or 0) for k in 'h m s'.split())
		if x and x.lower() == 'pm': h = h%12 + 12
		dt_filter['time'] = h, m, s
	# TZ
	m = re.search(r'^\[\s*(\S.*\S)\s*\]' + ts_str_re, ts_str)
	if m: dt_filter['tz'], ts_str = pytz.timezone(m.group(1).replace(' ', '_')), m.group('rest')
	# Leftovers
	if ts_str: raise TSParseError(ts_str)
	return IntervalFilter(**dt_filter)

def repr_ts(ts):
	if not ts: return str(ts)
	return conv_ts_local(ts)\
		.strftime('[%a %Y-%m-%d %H:%M:%S.%f %z]')

def repr_ts_diff( ts, ts0=None,
		ext=None, units_max=2, units_res=None,
		_units=dict( h=3600, m=60, s=1,
			y=365.25*86400, mo=30.5*86400, w=7*86400, d=1*86400 ) ):
	delta = abs(
		(ts - (ts0 or dt.datetime.now()))
		if not isinstance(ts, dt.timedelta) else ts )
	res, s, n_last = list(), delta.total_seconds(), units_max - 1
	for unit, unit_s in sorted(_units.items(), key=op.itemgetter(1), reverse=True):
		val = math.floor(s / unit_s)
		if not val: continue
		if len(res) == n_last or units_res == unit:
			val, n_last = round(s / unit_s), True
		res.append('{:.0f}{}'.format(val, unit))
		if n_last is True: break
		s -= val * unit_s
	if not res: return '-'
	else:
		if ext: res.append(ext)
		return ' '.join(res)

def apply_ts_delta( ts, delta,
		ts_limit=conv_ts_utc(dt.datetime.now()) + dt.timedelta(365) ):
	if isinstance(delta, IntervalDelta):
		for offset in delta:
			if isinstance(offset, tuple):
				n, k = offset
				if n != 0:
					n = getattr(ts, k) + n
					if k == 'month' and n > 12:
						while n > 12: ts, n = ts.replace(year=ts.year+1), n - 12
						ts = ts.replace(month=n)
					else: ts = ts.replace(**{k: n})
			elif offset.total_seconds() != 0: ts += offset
	elif isinstance(delta, IntervalFilter):
		ts0, ts_ref = ts, ts - delta_1d
		while True:
			if ts_ref > ts_limit: raise TSOverflow(ts_limit, delta)
			ts_ref += delta_1d
			if delta.tz: ts = delta.tz.localize(ts_ref.replace(tzinfo=None), is_dst=None)
			else: ts = conv_ts_local(ts_ref)
			if ( delta.mo_days
				and isinstance(delta.mo_days, set)
				and ts.day not in delta.mo_days ): continue
			if delta.weekdays and ts.isoweekday() not in delta.weekdays: continue
			ts = ts.replace( microsecond=0,
				**dict(zip('hour minute second'.split(), delta.time or (0, 0, 0))) )
			ts = conv_ts_utc(ts)
			if ts > ts0: break
	else: raise NotImplementedError(delta)
	return ts



### ReST parser

def parse_cal_list_from_rst(rst_str):
	from docutils import frontend as rst_front
	from docutils.parsers import rst
	import docutils.utils as rst_utils

	class RstLookupError(Exception): pass
	class RstLookupFound(Exception): pass

	def rst_lookup( root, tag,
			default=RstLookupError, recursive=False, one=True, text=True ):
		res, opts = list(), dict(one=one, recursive=recursive)
		tag = tag.split()
		if len(tag) > 1:
			opts_path = dict(opts.items(), text=False)
			for tag_path in tag[:-1]:
				if not root: break
				root = rst_lookup(root, tag_path, **opts_path)
			tag = tag[-1]
		else: tag = tag[0]
		if tag.endswith('...'): one, tag = False, tag[:-3]
		def collect(e):
			if one: raise RstLookupFound(e)
			if isinstance(e, list): res.extend(e)
			else: res.append(e)
		if not root: root = list()
		es = ( root.children if not isinstance(root, list)
			else it.chain.from_iterable(e.children for e in root) )
		try:
			for e in es:
				if e.tagname == tag: collect(e)
				if recursive:
					e = rst_lookup(e, tag, **opts)
					if e: collect(e)
		except RstLookupFound as res:
			res = res.args[0]
			return res if not text else res.astext()
		if one or not res:
			if default is not RstLookupError: return default
			raise RstLookupError(root, tag)
		if text: res = list(e.astext() for e in res)
		return res

	def rst_cal_info(root):
		try: fields = rst_lookup(root, 'field_list...', text=False)
		except RstLookupError: return
		res = dict()
		for e in rst_lookup(fields, 'field...', text=False):
			key = rst_lookup(e, 'field_name').replace('-', '_')
			res.setdefault(key, list()).append(rst_lookup(e, 'field_body paragraph'))
		if not (res.get('ts') or res.get('ts_start')): return
		ts_str_norm = lambda ts: ts.replace('_', ' ').strip()
		if res.get('ts'):
			ts_str_list, res['ts'] = res['ts'], list()
			res['raw_ts'] = ts_str_list
			for ts in ts_str_list:
				ts = ts_str_norm(ts)
				if not ts: continue
				m = re.search(r'^every\s+(.*)', ts)
				res['ts'].append( parse_ts(ts)
					if not m else parse_ts_interval(m.group(1)) )
		else: res['ts'] = res['raw_ts'] = list()
		for k in 'ts_start', 'ts_end', 'duration':
			k_raw = f'raw_{k}'
			if not res.get(k):
				res[k] = res[k_raw] = None
				continue
			assert len(res[k]) == 1, [k, res[k]]
			res[k_raw], res[k] = res[k], ( parse_ts
				if k != 'duration' else parse_duration )(ts_str_norm(res[k][0]))
		return res

	def rst_cal_list(root, depth=0, sections=None, cals=None):
		if cals is None: cals = list()
		if not sections: sections = list()
		for e in root.children:
			e_sec = None
			if e.tagname == 'section':
				e_sec = sections.copy() + [rst_lookup(e, 'title')]
			cal_info = rst_cal_info(e)
			if cal_info:
				if not cal_info.get('title'):
					cal_info['title'] = ( e_sec[-1]
						if e_sec else rst_lookup(e, 'paragraph') )
				cal_info['path'] = sections
				cals.append(cal_info)
			rst_cal_list(e, depth+1, e_sec or sections, cals)
		return cals

	settings = rst_front.OptionParser(components=(rst.Parser,)).get_default_values()
	rst_tree = rst_utils.new_document('cal_list', settings)
	rst.Parser().parse(rst_str, rst_tree)
	return rst_cal_list(rst_tree)



### Conky config generator

ConkyEvent = cs.namedtuple('ConkyEvent', 'ts0 ts1 title')

conky_params_default = dict(
	max_text_lines=9, max_text_break='${alignr}[more]', max_text_color='d9374c',
	eta_res='h', line_color='aaa', line_pos=-9, line_step=1, line_w=1,
	color='', c_weekday='lightgray', c_date='gray', c_time='lightgray', c_title='',
	c_eta_day='lightgray', c_eta_pass='999', c_eta_12='42a150', c_eta_6='9ebd5f',
	c_eta_4='d9d277', c_eta_3='f4ae58', c_eta_2='e87733', c_eta_1='d10027',
	pos_weekday=65, pos_date=0, pos_title=170,
	pos_time_fixed=110, pos_time_span=100, pos_time_from=100, pos_time_until=100 )

def conky_event_time_repr(ts_now, day, ts0, ts1):
	'Return string repr for time within specified day, time/span type and delta until event.'
	tk = None
	if ts0 == ts1 or (ts1 - ts0).total_seconds() < 3*60:
		if not ts0.hour == ts0.minute == 0: tk = 'fixed'
	elif (ts0 - delta_1s).date() < day and (ts1 + delta_1s).date() > day: pass # whole day
	elif ts0.date() == day and ts1.date() == day: tk = 'span'
	elif (ts0 - delta_1s).date() == day: tk = 'from'
	elif (ts1 + delta_1s).date() == day: tk = 'until'

	ts = conv_ts_local(ts_now) # for correct ts.date()
	if tk == 'fixed':
		delta, day_ts = ts0 - ts, ts0.strftime('%H:%M')
	elif tk == 'span':
		day_ts = ts0.strftime('%H:%M') + '-' + ts1.strftime('%H:%M')
		delta = (ts1 - ts) if ts > ts1 else (
			(dt.timedelta(0) if ts > ts0 else (ts0 - ts)) )
	elif tk == 'from':
		day_ts = 'from ' + ts0.strftime('%H:%M')
		delta = dt.timedelta(0) if ts > ts0 else (ts0 - ts)
	elif tk == 'until':
		day_ts = 'until ' + ts1.strftime('%H:%M')
		delta = ( (ts1 - ts) if ts > ts1 else
			((ts0 - ts) if ts < ts0 else dt.timedelta(0)) )
	else:
		day_ts = None
		delta = ( dt.timedelta(0) if ts.date() == day
			else ((ts0 - ts) if ts < ts0 else (ts - ts1)) )

	return day_ts, tk, delta

def conky_eta_color(delta, cc):
	s = delta.total_seconds()
	if s < 0: return cc.c_eta_pass
	if s > 24 * 3600: return cc.c_eta_day
	k = None
	for n in range(24, 0, -1):
		k_new = f'c_eta_{n}'
		if k_new not in cc: continue
		if s <= n * 3600: k = k_new
		else: break
	return cc.get(k) or ''

def conky_config_gen(dst, ts_now, day0, day1, events, conky_params):
	day, cc, lines, delta_dedup = day0, adict(conky_params), 0, set()
	cc.max_text_lines = int(cc.max_text_lines) - 1
	while day < day1:
		day_events = list()
		for ts0, ts1, title in events:
			if not ts0.date() <= day <= ts1.date(): continue
			day_ts, tk, delta = conky_event_time_repr(ts_now, day, ts0, ts1)
			day_events.append((day_ts, tk, delta, title))

		if day_events and lines <= cc.max_text_lines:
			if lines:
				dst.write(
					f'${{color {cc.line_color}}}${{voffset {cc.line_pos}}}'
					f'${{stippled_hr {cc.line_step} {cc.line_w}}}'
					f'${{voffset {-int(cc.line_pos)}}}${{color {cc.color}}}' )
			dst.write(day.strftime(
				f'${{goto {cc.pos_weekday}}}${{color {cc.c_weekday}}}%a${{color}}'
				f'${{goto {cc.pos_date}}}${{color {cc.c_date}}}%Y-%m-%d${{color}}' ))

			for day_ts, tk, delta, title in day_events:
				if lines > cc.max_text_lines: continue
				if day_ts:
					pos = cc[f'pos_time_{tk}']
					dst.write( f'${{goto {pos}}}'
						f'${{color {cc.c_time}}}{day_ts}${{color {cc.color}}}' )
				if title not in delta_dedup:
					delta_dedup.add(title)
					delta_str = repr_ts_diff(
						delta, units_res=cc.eta_res,
						ext=None if delta.total_seconds() >= 0 else 'ago' )
					title += f'${{alignr}}${{color {conky_eta_color(delta, cc)}}}[ {delta_str} ]'
				dst.write( f'${{goto {cc.pos_title}}}'
					f'${{color {cc.c_title}}}{title}${{color {cc.color}}}' )
				if lines == cc.max_text_lines:
					dst.write( f' ${{color {cc.max_text_color}}}'
						f'{cc.max_text_break}${{color {cc.color}}}' )
				lines += 1
				dst.write('\n')

		day += delta_1d



### CLI

def main(args=None):
	conky_params_default_str = ' '.join(f'{c}={o}' for c, o in conky_params_default.items())

	import argparse, textwrap

	dedent = lambda text: (textwrap.dedent(text).strip('\n') + '\n').replace('\t', '  ')
	text_fill = lambda s,w=100,ind='\t',**k: textwrap.fill(
		s, w, initial_indent=ind, subsequent_indent=ind, **k )
	class SmartHelpFormatter(argparse.HelpFormatter):
		def __init__(self, *args, **kws):
			return super().__init__(*args, **kws, width=100)
		def _fill_text(self, text, width, indent):
			if '\n' not in text: return super()._fill_text(text, width, indent)
			return ''.join( indent + line
				for line in text.replace('\t', '  ').splitlines(keepends=True) )
		def _split_lines(self, text, width):
			return super()._split_lines(text, width)\
				if '\n' not in text else dedent(text).splitlines()

	parser = argparse.ArgumentParser(
		formatter_class=SmartHelpFormatter,
		description='ReST-based calendar parser and online event tracker.')

	group = parser.add_argument_group('Input/output options')
	group.add_argument('rst_file', nargs='?',
		help='''
			ReST (.rst) file with calendar and event descriptions.
			Will be read from stdin, if "-" or not specified.''')
	group.add_argument('-i', '--ical', metavar='path',
		help='''
			Generate ICS (icalendar) output file at specified path.
			"-" can be unsed instead of path to output to stdout instead.''')
	group.add_argument('-c', '--conky', metavar='path',
		help='''
			Generate conky configuration snippet for e.g. execi or catp include/command.
			 "-" can be unsed instead of path to output to stdout instead.''')
	group.add_argument('-w', '--conky-params',
		metavar='col=offset,color=value,...', default=conky_params_default_str,
		help='''
			Various conky parameters in calendar table generated by -c/--conky option.
			Overrides for one or more values can be specified in any order,
				separated by commas and/or spaces.
			Default offsets are:\n{}'''.format(
				text_fill(conky_params_default_str, len(conky_params_default_str) // 5 - 5, '\t'*4) ))

	group = parser.add_argument_group('Event filtering')
	group.add_argument('-e', '--event', metavar='title-part',
		help='Only match event(s) with specified part (case-insensitive) included in the title.')
	group.add_argument('-s', '--time-start', metavar='time', default='00:00',
		help='Time to use as a min cutoff point,'
			' i.e. disregard anything that is passed by it. Default: %(default)s')
	group.add_argument('-l', '--time-span', metavar='delta', default='1mo',
		help='Time delta from -s/--time-start to generate calendar entries for. Default: %(default)s')

	group = parser.add_argument_group('Misc options')
	group.add_argument('--debug', action='store_true', help='Verbose operation mode.')

	opts = parser.parse_args(sys.argv[1:] if args is None else args)

	logging.basicConfig(
		format='%(levelname)s :: %(message)s',
		level=logging.DEBUG if opts.debug else logging.WARNING )

	with open( sys.stdin.fileno()
			if not opts.rst_file or opts.rst_file == '-' else opts.rst_file ) as src:
		doc_text = src.read()

	ts_min = conv_ts_utc(parse_ts(opts.time_start, in_future=False))
	ts_max = ts_min + parse_duration(opts.time_span)
	ts0_cache_mock = ts_min - delta_1d # XXX: per-entry cache

	if opts.ical:
		import icalendar as ic # https://tools.ietf.org/html/rfc5545
		ical, ev = ic.Calendar(), None
		ical.add('prodid', '-//rst-icalendar-event-tracker//fraggod.net//EN')
		ical.add('version', '2.0')
	if opts.conky:
		conky, conky_params = list(), conky_params_default.copy()
		if opts.conky_params:
			for spec in it.chain.from_iterable(
					col.strip().split() for col in opts.conky_params.split(',') ):
				try:
					k, v = spec.split('=', 1)
					if k not in conky_params: raise ValueError(k)
					conky_params[k] = v
				except ValueError:
					parser.error(f'Invalid column/width spec: {spec!r}')

	cal_list = parse_cal_list_from_rst(doc_text)
	for cal in map(adict, cal_list):
		if opts.event and opts.event.lower() not in cal.title.lower(): continue

		ts_list, ts0, ts1 = cal.ts, cal.ts_start, cal.ts_end
		ts0, ts1 = map(conv_ts_utc, [ts0, ts1])
		if ts1 and ts1 < ts0: ts1 = ts1.replace(year=ts1.year + 1)
		ts0_cache = ts0_cache_mock if not ts0 else None
		for ts in ts_list:
			if isinstance(ts, dt.datetime):
				if ts0 and ts1:
					log.warning( 'Ignoring fixed-time "ts" field for entry,'
						' as "ts-start"/"ts-end" are used instead: {!r} [{}]', cal.title, ts )
				elif not ts0: ts0 = conv_ts_utc(ts)
			else:
				if not ts0: ts0 = ts0_cache or ts_min
				if ts1 and ts0 > ts1: # event ending in the past
					ts0 = None
					break
				try:
					while ts0 < ts_min: ts0 = apply_ts_delta(ts0, ts, ts_max)
				except TSOverflow: # no events within timespan
					ts0 = None
					break
				if isinstance(ts, IntervalFilter) and not ts.time: # day spans
					ts1 = ts0
					while True: # iterate until span ends
						try: ts1_next = apply_ts_delta(ts1, ts, ts_max)
						except TSOverflow: break
						if ts1_next != ts1 + delta_1d: break
						ts1 = ts1_next
					ts1 += delta_1d - delta_1s # extend until end of last day

		if not ts0: continue
		if not ts1:
			ts1 = ts0
			if cal.duration: ts1 += cal.duration
		if ts1 < ts_min or ts0 > ts_max: continue
		loc_ts0, loc_ts1 = map(conv_ts_local, [ts0, ts1])

		log.debug('----- title: {}', cal.title)
		log.debug('  cache: {}', repr_ts(ts0_cache))
		log.debug('  raw:   {} {} {}', cal.raw_ts, cal.raw_ts_start, cal.raw_ts_end)
		log.debug('  result [{}]:', repr_ts_diff(ts1 - ts0))
		log.debug('    from: {}', repr_ts(loc_ts0))
		log.debug('    to:   {}', repr_ts(loc_ts1))

		if opts.ical:
			ev = ic.Event()
			ev.add('summary', cal.title)
			ev.add('dtstart', conv_ts_local(ts0))
			ev.add('dtend', conv_ts_local(ts1))
			ev.add('dtstamp', conv_ts_local(ts_min))
			if cal.get('url'): ev.add('url', cal.url)
			ical.add_component(ev)
		if opts.conky: conky.append(ConkyEvent(loc_ts0, loc_ts1, cal.title))

	if opts.ical:
		if ev:
			log.debug('Generating resulting ICS file...')
			dst_stream = ( open(sys.stdout.fileno(), 'wb')
				if opts.ical == '-' else safe_replacement(opts.ical) )
			with dst_stream as dst: dst.write(ical.to_ical())
		else: log.debug('No calendar entries within timespan, skipping ICS generation')

	if opts.conky:
		log.debug('Generating conky configuration snippet...')
		ts_now = dt.datetime.utcnow().replace(tzinfo=pytz.utc)
		day0, day1 = conv_ts_local(ts_min).date(), conv_ts_local(ts_max).date()
		dst_stream = ( open(sys.stdout.fileno(), 'w')
			if opts.conky == '-' else safe_replacement(opts.conky) )
		with dst_stream as dst:
			conky_config_gen(dst, ts_now, day0, day1, conky, conky_params)

if __name__ == '__main__': sys.exit(main())
