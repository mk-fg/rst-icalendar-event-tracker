#!/usr/bin/env python3

import itertools as it, operator as op, functools as ft
import os, sys, logging, re, time, math, subprocess
import datetime as dt, collections as cs

import docutils, pytz


class adict(dict):
	def __init__(self, *args, **kwargs):
		super().__init__(*args, **kwargs)
		self.__dict__ = self

class LogMessage(object):
	def __init__(self, fmt, a, k): self.fmt, self.a, self.k = fmt, a, k
	def __str__(self): return self.fmt.format(*self.a, **self.k) if self.a or self.k else self.fmt

class LogStyleAdapter(logging.LoggerAdapter):
	def __init__(self, logger, extra=None):
		super(LogStyleAdapter, self).__init__(logger, extra or {})
	def log(self, level, msg, *args, **kws):
		if not self.isEnabledFor(level): return
		log_kws = {} if 'exc_info' not in kws else dict(exc_info=kws.pop('exc_info'))
		msg, kws = self.process(msg, kws)
		self.logger._log(level, LogMessage(msg, args, kws), (), **log_kws)

get_logger = lambda name: LogStyleAdapter(logging.getLogger(name))
log = get_logger('main')



### Date/time processing helpers

class TSParseError(Exception): pass
class TSOverflow(Exception): pass

IntervalFilter = cs.namedtuple('interval_filter', 'mo_days weekdays time tz')
IntervalDelta = cs.namedtuple('interval_delta', 'y mo w d h m s')

weekday_names = 'mon tue wed thu fri sat sun'.title().split()

_short_ts_days = dict(
	y=365.25, yr=365.25, year=365.25,
	mo=30.5, month=30.5, w=7, week=7, d=1, day=1 )
_short_ts_s = dict(
	h=3600, hr=3600, hour=3600,
	m=60, min=60, minute=60,
	s=1, sec=1, second=1 )
def _short_ts_re():
	sub_sort = lambda d: sorted(
		d.items(), key=lambda kv: (kv[1], len(kv[0])), reverse=True )
	ts_re = ['^'] + [
		r'(?P<{0}>\d*{0}\b\s*)?'.format(k)
		for k, v in it.chain.from_iterable(
			map(sub_sort, [_short_ts_days, _short_ts_s]) ) ] + ['$']
	return re.compile(''.join(ts_re), re.I | re.U)
_short_ts_re = _short_ts_re()

_filter_weekdays = list(map(str.split,
	[ 'mon monday', 'tu tue tuesday tues', 'wed wednesday',
		'th thu thursday thur thurs', 'fri friday', 'sat saturday', 'sun sunday' ] ))
_filter_weekdays_re = '(?:{})'.format(
	'|'.join('|'.join(wd) for wd in _filter_weekdays) )

def _delta_keys():
	ks = dict()
	for delta_k in IntervalDelta._fields:
		for vs in _short_ts_days, _short_ts_s:
			if delta_k not in vs: continue
			v_chk = vs[delta_k]
			for k, v in vs.items():
				if v == v_chk: ks[k] = delta_k
			break
		else: raise TSParseError(delta_k)
	return ks
_delta_keys = _delta_keys()
_delta_keys_dt = dict(
	y=(1, 'year'), mo=(1, 'month'), w=dt.timedelta(weeks=1), d=dt.timedelta(days=1),
	h=dt.timedelta(hours=1), m=dt.timedelta(minutes=1), s=dt.timedelta(seconds=1) )

_parse_int = lambda v: int(''.join(c for c in v if c.isdigit()) or 1)

def get_local_tz():
	if get_local_tz.cache: return get_local_tz.cache

	tz = os.environ.get('TZ', '').strip()
	if tz:
		get_local_tz.cache = pytz.timezone(tz)
		return get_local_tz.cache

	import ctypes as ct

	class sd_bus(ct.Structure): pass
	class sd_bus_error(ct.Structure):
		_fields_ = [('name', ct.c_char_p), ('message', ct.c_char_p), ('need_free', ct.c_int)]
	class sd_bus_msg(ct.Structure): pass

	lib = ct.CDLL('libsystemd.so')

	def run(call, *args, sig=None, check=True):
		func = getattr(lib, call)
		if sig: func.argtypes = sig
		res = func(*args)
		if check and res < 0: raise OSError(-res, os.strerror(-res))
		return res

	bus, error, reply = (
		ct.POINTER(sd_bus)(), sd_bus_error(), ct.POINTER(sd_bus_msg)() )
	run( 'sd_bus_open_system', ct.byref(bus),
		sig=[ct.POINTER(ct.POINTER(sd_bus))] )
	try:
		run( 'sd_bus_get_property',
			bus,
			b'org.freedesktop.timedate1',
			b'/org/freedesktop/timedate1',
			b'org.freedesktop.timedate1',
			b'Timezone',
			ct.byref(error),
			ct.byref(reply),
			b's',
			sig=[
				ct.POINTER(sd_bus),
				ct.c_char_p, ct.c_char_p, ct.c_char_p, ct.c_char_p,
				ct.POINTER(sd_bus_error),
				ct.POINTER(ct.POINTER(sd_bus_msg)),
				ct.c_char_p ] )
		tz = ct.c_char_p()
		n = run( 'sd_bus_message_read', reply, b's', ct.byref(tz),
			sig=[ct.POINTER(sd_bus_msg), ct.c_char_p, ct.POINTER(ct.c_char_p)] )
		assert n > 0, n
	finally:
		run('sd_bus_flush', bus, check=False)
		run('sd_bus_close', bus, check=False)
		run('sd_bus_unref', bus, check=False)
	get_local_tz.cache = pytz.timezone(tz.value.decode())
	return get_local_tz.cache
get_local_tz.cache = None

def normalize_ts(ts):
	if not ts: return
	if not ts.tzinfo: ts = get_local_tz().localize(ts)
	return ts.astimezone(pytz.utc)

def localize_ts(ts):
	if not ts: return
	return ts.astimezone(get_local_tz())

def parse_delta_spec(ts_str):
	m = _short_ts_re.search(ts_str)
	if not m or not any(m.groups()): raise TSParseError(ts_str)
	delta = dict.fromkeys(IntervalDelta._fields, 0)
	for k, delta_k in _delta_keys.items():
		try: n = _parse_int(m.group(k)) if m.group(k) else 0
		except IndexError: n = 0
		delta[delta_k] += n
	for delta_k, n in delta.items():
		v = _delta_keys_dt[delta_k]
		if isinstance(v, dt.timedelta): v *= n
		else: v = v[0]*n, v[1]
		delta[delta_k] = v
	return IntervalDelta(**delta)

def parse_duration(ts_str):
	m = _short_ts_re.search(ts_str)
	if not m or not any(m.groups()): raise TSParseError(ts_str)
	delta = list()
	for units in _short_ts_days, _short_ts_s:
		val = 0
		for k, v in units.items():
			try:
				if not m.group(k): continue
				n = _parse_int(m.group(k))
			except IndexError: continue
			val += n * v
		delta.append(val)
	return dt.timedelta(*delta)

def parse_ts(ts_str):
	assert isinstance(ts_str, str), [type(ts_str), repr(ts_str)]
	ts = None
	if not ts:
		match = re.search( # common BE format
			r'^(?P<date>(?:\d{2}|(?P<Y>\d{4}))-\d{2}-\d{2})'
			r'(?:[ T](?P<time>\d{2}(?::\d{2}(?::\d{2})?)?)?)?$', ts_str )
		if match:
			tpl = 'y' if not match.group('Y') else 'Y'
			tpl, ts_str = '%{}-%m-%d'.format(tpl), match.group('date')
			if match.group('time'):
				tpl_time = ['%H', '%M', '%S']
				ts_str_time = match.group('time').split(':')
				ts_str += ' ' + ':'.join(ts_str_time)
				tpl += ' ' + ':'.join(tpl_time[:len(ts_str_time)])
			try: ts = dt.datetime.strptime(ts_str, tpl)
			except ValueError: pass
	if not ts:
		# coreutils' "date" parses virtually everything, but is more expensive to use
		proc = subprocess.Popen( ['date', '+%s', '-d', ts_str],
				stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, close_fds=True )
		val = proc.stdout.read()
		if not proc.wait():
			val = int(val.strip())
			# Try to add +1 day to simple timestamps like 3:00 if they're in the past
			# Whitelisted cases: 1:00, 4am, 5am GMT, 3:30 UTC-4
			if 0 < time.time() - val <= 24*3600 and re.search(
					r'(?i)^[\d:]+\s*(am|pm)?\s*([-+][\d:]+|\w+|\w+[-+][\d:]+)?$', ts_str.strip() ):
				val += 24*3600
			ts = dt.datetime.fromtimestamp(val)
			if 0 < time.time() - val <= 365*24*3600 and not re.search(r'\b\d{4}\b', ts_str):
				ts = ts.replace(year=ts.year+1)
	if ts: return ts
	raise TSParseError(ts_str)

def parse_ts_interval(ts_str):
	# EVERY:
	#   "every" {
	#     [ ( NN[suffix][ "-" MM[suffix]] )+ | DELTA-DATE-SPEC ]
	#       [WD[-WD]]+
	#       ["at"] [TIME ["[" TZ "]"]]
	#     | DELTA-SPEC "interval" }
	#   suffix: st, nd, rd, th
	#   example: every 1st-11th at 5am UTC
	# DELTA-SPEC:
	#   ( N || unit )+
	#   units:
	#     y, yr, year, mo, month, w, week, d, day,
	#     h, hr, hour, m, min, minute, s, sec, second
	#   example: 3mo 1d 5hrs 10minutes 30s
	# DELTA-DATE-SPEC:
	#   subset of DELTA-SPEC wrt allowed units
	#   units: y, yr, year, mo, month, w, week, d, day
	# WD: see _filter_weekdays abbrevs
	# TIME: [H]H[:MM[:SS]] ["am"|"pm"]
	# TZ: ( "UTC" | ("+"|"-") XX:YY | region/place )

	# DELTA-SPEC "interval"
	m = re.search(r'(?i)^(.*)\binterval$', ts_str)
	if m: return parse_delta_spec(m.group(1).strip())

	# More conventional specification
	ts_str_base, dt_filter = ts_str, dict.fromkeys(IntervalFilter._fields)
	mo_days = dt_filter['mo_days'] = set()
	weekdays = dt_filter['weekdays'] = set()
	ts_str_re = r'(\s+(?P<rest>.*)|$)'

	# ( NN[suffix][ "-" MM[suffix]] )+
	while True:
		m = re.search( r'(?i)^(?P<a>\d+)(st|nd|rd|th)?'
			r'(\s*-\s*(?P<b>\d+)(st|nd|rd|th)?)?' + ts_str_re, ts_str )
		if not m: break
		a, b, ts_str = m.group('a'), m.group('b'), m.group('rest') or ''
		if b: mo_days.update(range(int(a), int(b)+1))
		else: mo_days.add(int(a))
	# DELTA-DATE-SPEC
	spec, delta, ts_str = ts_str.split(), None, list()
	while True:
		if not spec: break
		try: delta = parse_delta_spec(' '.join(spec))
		except TSParseError: pass
		else: break
		ts_str.append(spec.pop())
	if delta:
		if mo_days: raise TSParseError(' '.join(spec), mo_days, delta)
		if delta.h or delta.m or delta.s: raise TSParseError(' '.join(spec), delta)
		dt_filter['mo_days'] = delta
	ts_str = ' '.join(reversed(ts_str))
	# [WD[-WD]]+
	wd_re = re.compile( r'(?i)^(?P<a>{0})(\s*-\s*'
		r'(?P<b>{0}))?{1}'.format(_filter_weekdays_re, ts_str_re) )
	wd_match = lambda s: next( n for n, wd in
		enumerate(_filter_weekdays, 1) if s.startswith(wd[0]) )
	while True:
		m = wd_re.search(ts_str)
		if not m: break
		a, b, ts_str = m.group('a'), m.group('b'), m.group('rest') or ''
		if b: weekdays.update(range(wd_match(a.lower()), wd_match(b.lower())+1))
		else: weekdays.add(wd_match(a.lower()))
	# "at"
	m = re.search(r'(?i)^\s*at' + ts_str_re, ts_str)
	if m: ts_str = m.group('rest') or ''
	# TIME
	m = re.search( r'(?i)^(?P<h>\d{1,2})(:(?P<m>\d{2})'
		r'(:(?P<s>\d{2}))?)?(\s*(?P<x>am|pm))?' + ts_str_re, ts_str )
	if m:
		x, ts_str = m.group('x'), m.group('rest') or ''
		h, m, s = (int(m.group(k) or 0) for k in 'h m s'.split())
		if x.lower() == 'pm': h = h%12 + 12
		dt_filter['time'] = h, m, s
	# TZ
	m = re.search(r'^\[\s*(\S.*\S)\s*\]' + ts_str_re, ts_str)
	if m:
		import pytz
		dt_filter['tz'], ts_str = pytz.timezone(m.group(1).replace(' ', '_')), m.group('rest')
	# Leftovers
	if ts_str: raise TSParseError(ts_str)
	return IntervalFilter(**dt_filter)

def repr_ts_diff( ts, ts0=None, ext=None,
		_units=dict( h=3600, m=60, s=1,
			y=365.25*86400, mo=30.5*86400, w=7*86400, d=1*86400 ) ):
	delta = abs(
		(ts - (ts0 or dt.datetime.now()))
		if not isinstance(ts, dt.timedelta) else ts )
	res, s = list(), delta.total_seconds()
	for unit, unit_s in sorted(_units.items(), key=op.itemgetter(1), reverse=True):
		val = math.floor(s / float(unit_s))
		if not val: continue
		res.append('{:.0f}{}'.format(val, unit))
		if len(res) >= 2: break
		s -= val * unit_s
	if not res: return '-'
	else:
		if ext: res.append(ext)
		return ' '.join(res)

def apply_ts_delta( ts, delta,
		ts_limit=normalize_ts(dt.datetime.now()) + dt.timedelta(365) ):
	if isinstance(delta, IntervalDelta):
		for offset in delta:
			if isinstance(offset, tuple):
				n, k = offset
				if n != 0:
					n = getattr(ts, k) + n
					if k == 'month' and n > 12:
						while n > 12: ts, n = ts.replace(year=ts.year+1), n - 12
						ts = ts.replace(month=n)
					else: ts = ts.replace(**{k: n})
			elif offset.total_seconds() != 0: ts += offset
	elif isinstance(delta, IntervalFilter):
		day = dt.timedelta(1)
		ts0, ts = ts, ts - day
		if not ts0.tzinfo: ts0
		while True:
			if ts > ts_limit: raise TSOverflow(ts_limit, delta)
			ts += day
			if ( delta.mo_days
				and isinstance(delta.mo_days, set)
				and ts.day not in delta.mo_days ): continue
			if delta.weekdays and ts.isoweekday() not in delta.weekdays: continue
			if delta.time: ts = ts.replace(**dict(zip('hour minute second'.split(), delta.time)))
			if delta.tz: ts = normalize_ts(delta.tz.localize(ts.replace(tzinfo=None)))
			if ts > ts0: return ts
	else: raise NotImplementedError(delta)
	return ts



### ReST parser

def parse_cal_list_from_rst(rst_str):
	from docutils import frontend as rst_front
	from docutils.parsers import rst
	import docutils.utils as rst_utils

	class RstLookupError(Exception): pass
	class RstLookupFound(Exception): pass

	def rst_lookup( root, tag,
			default=RstLookupError, recursive=False, one=True, text=True ):
		res, opts = list(), dict(one=one, recursive=recursive)
		tag = tag.split()
		if len(tag) > 1:
			opts_path = dict(opts.items(), text=False)
			for tag_path in tag[:-1]:
				if not root: break
				root = rst_lookup(root, tag_path, **opts_path)
			tag = tag[-1]
		else: tag = tag[0]
		if tag.endswith('...'): one, tag = False, tag[:-3]
		def collect(e):
			if one: raise RstLookupFound(e)
			if isinstance(e, list): res.extend(e)
			else: res.append(e)
		if not root: root = list()
		es = ( root.children if not isinstance(root, list)
			else it.chain.from_iterable(e.children for e in root) )
		try:
			for e in es:
				if e.tagname == tag: collect(e)
				if recursive:
					e = rst_lookup(e, tag, **opts)
					if e: collect(e)
		except RstLookupFound as res:
			res = res.args[0]
			return res if not text else res.astext()
		if one or not res:
			if default is not RstLookupError: return default
			raise RstLookupError(root, tag)
		if text: res = list(e.astext() for e in res)
		return res

	def rst_cal_info(root):
		try: fields = rst_lookup(root, 'field_list...', text=False)
		except RstLookupError: return
		res = dict()
		for e in rst_lookup(fields, 'field...', text=False):
			key = rst_lookup(e, 'field_name').replace('-', '_')
			res.setdefault(key, list()).append(rst_lookup(e, 'field_body paragraph'))
		if not (res.get('ts') or res.get('ts_start')): return
		ts_str_norm = lambda ts: ts.replace('_', ' ').strip()
		if res.get('ts'):
			ts_str_list, res['ts'] = res['ts'], list()
			res['raw_ts'] = ts_str_list
			for ts in ts_str_list:
				ts = ts_str_norm(ts)
				if not ts: continue
				m = re.search(r'^every\s+(.*)', ts)
				res['ts'].append( parse_ts(ts)
					if not m else parse_ts_interval(m.group(1)) )
		else: res['ts'] = res['raw_ts'] = list()
		for k in 'ts_start', 'ts_end', 'duration':
			k_raw = f'raw_{k}'
			if not res.get(k):
				res[k] = res[k_raw] = None
				continue
			assert len(res[k]) == 1, [k, res[k]]
			res[k_raw], res[k] = res[k], ( parse_ts
				if k != 'duration' else parse_duration )(ts_str_norm(res[k][0]))
		return res

	def rst_cal_list(root, depth=0, sections=None, cals=None):
		if cals is None: cals = list()
		if not sections: sections = list()
		for e in root.children:
			e_sec = None
			if e.tagname == 'section':
				e_sec = sections.copy() + [rst_lookup(e, 'title')]
			cal_info = rst_cal_info(e)
			if cal_info:
				if not cal_info.get('title'):
					cal_info['title'] = ( e_sec[-1]
						if e_sec else rst_lookup(e, 'paragraph') )
				cal_info['path'] = sections
				cals.append(cal_info)
			rst_cal_list(e, depth+1, e_sec or sections, cals)
		return cals

	settings = rst_front.OptionParser(components=(rst.Parser,)).get_default_values()
	rst_tree = rst_utils.new_document('cal_list', settings)
	rst.Parser().parse(rst_str, rst_tree)
	return rst_cal_list(rst_tree)



### CLI

def main(args=None):
	import argparse, textwrap

	dedent = lambda text: (textwrap.dedent(text).strip('\n') + '\n').replace('\t', '  ')
	class SmartHelpFormatter(argparse.HelpFormatter):
		def __init__(self, *args, **kws):
			return super().__init__(*args, **kws, width=100)
		def _fill_text(self, text, width, indent):
			if '\n' not in text: return super()._fill_text(text, width, indent)
			return ''.join(indent + line for line in text.splitlines(keepends=True))
		def _split_lines(self, text, width):
			return super()._split_lines(text, width)\
				if '\n' not in text else dedent(text).splitlines()

	parser = argparse.ArgumentParser(
		description='ReST-based calendar parser and online event tracker.')
	parser.add_argument('rst_file', nargs='?',
		help='ReST (.rst) file with calendar and event descriptions.'
			' Will be read from stdin, if "-" or not specified.')
	# parser.add_argument('-c', '--cache', metavar='path', help='Path to cache file.')
	parser.add_argument('-t', '--timespan', metavar='delta', default='1w',
		help='Time delta from now to generate calendar entries for. Default: %(default)s')
	parser.add_argument('--debug', action='store_true', help='Verbose operation mode.')
	opts = parser.parse_args(sys.argv[1:] if args is None else args)

	logging.basicConfig( datefmt='%Y-%m-%d %H:%M:%S',
		# format='%(asctime)s :: %(name)s %(levelname)s :: %(message)s',
		format='%(levelname)s :: %(message)s',
		level=logging.DEBUG if opts.debug else logging.WARNING )

	with open( sys.stdin.fileno()
			if not opts.rst_file or opts.rst_file == '-' else opts.rst_file ) as src:
		doc_text = src.read()

	ts_now = dt.datetime.utcnow().replace(tzinfo=pytz.utc)
	ts0_cache_mock = ts_now - dt.timedelta(1) # XXX: per-entry cache

	cal_list = parse_cal_list_from_rst(doc_text)
	for cal in map(adict, cal_list):
		ts_list, ts0, ts1 = cal.ts, cal.ts_start, cal.ts_end
		ts0, ts1 = map(normalize_ts, [ts0, ts1])
		ts0_cache = ts0_cache_mock if not ts0 else None
		for ts in ts_list:
			if isinstance(ts, dt.datetime):
				if ts0 and ts1:
					log.warning( 'Ignoring fixed-time "ts" field for entry,'
						' as "ts-start"/"ts-end" are used instead: {!r} [{}]', cal.title, ts )
				elif not ts0: ts0 = normalize_ts(ts)
			else:
				if not ts0: ts0 = ts0_cache or ts_now
				if ts1 and ts0 > ts1: continue # skip past event
				while ts0 < ts_now: ts0 = apply_ts_delta(ts0, ts)
			assert ts0, cal
			if not ts1:
				ts1 = ts0
				if cal.duration: ts1 += cal.duration

			log.debug('----- title: {}', cal.title)
			log.debug('  cache: {}', localize_ts(ts0_cache))
			log.debug('  raw:   {} {} {}', cal.raw_ts, cal.raw_ts_start, cal.raw_ts_end)
			log.debug('  result [{}]:', repr_ts_diff(ts1 - ts0))
			log.debug('    from: {} {}', weekday_names[ts0.weekday()], localize_ts(ts0))
			log.debug('    to:   {} {}', weekday_names[ts0.weekday()], localize_ts(ts1))

if __name__ == '__main__': sys.exit(main())
